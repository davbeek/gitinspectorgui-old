# noinspection PyPep8Naming

import multiprocessing
import sys
import threading
import time
from datetime import datetime
from logging import getLogger
from multiprocessing.managers import SyncManager
from pathlib import Path
from queue import Queue
from typing import Any

import PySimpleGUI as sg  # type: ignore

from gigui import _logging, shared
from gigui._logging import add_cli_handler, set_logging_level_from_verbosity
from gigui.args_settings import Args, Settings, SettingsFile
from gigui.constants import (
    AUTO,
    DEBUG_SHOW_MAIN_EVENT_LOOP,
    DYNAMIC_BLAME_HISTORY,
    FILE_FORMATS,
    MAX_COL_HEIGHT,
    NONE,
    WINDOW_HEIGHT_CORR,
)
from gigui.gi_runner import GIRunner
from gigui.gui.psg_base import PSGBase, help_window, log, popup
from gigui.gui.psg_window import make_window
from gigui.keys import Keys
from gigui.messages import CLOSE_OUTPUT_VIEWERS_MSG
from gigui.queues_events import RunnerQueues, get_runner_queues
from gigui.tiphelp import Help, Tip
from gigui.utils import open_file, to_posix_fstr

logger = getLogger(__name__)

tip = Tip()
keys = Keys()


class PSGUI(PSGBase):
    def __init__(
        self,
        settings: Settings,  # pylint: disable=redefined-outer-name
    ) -> None:
        super().__init__(settings)

        self.queues: RunnerQueues  # defined when the event keys.run is triggered
        self.manager: SyncManager | None = (
            None  # defined when the event keys.run is triggered
        )
        self.logging_queue: Queue  # defined when the event keys.run is triggered
        self.gi_runner_thread: threading.Thread | None = None
        self.recreate_window: bool = True

        while self.recreate_window:
            self.recreate_window = self.run_inner()
            set_logging_level_from_verbosity(self.settings.verbosity)

    # pylint: disable=too-many-locals disable=too-many-branches disable=too-many-statements
    def run_inner(self) -> bool:
        gi_runner: GIRunner
        logger.debug(f"{self.settings = }")  # type: ignore

        shared.gui = True

        # Is set to True when handling "Reset settings file" menu item
        recreate_window: bool = False

        if sys.platform == "darwin":
            sg.set_options(font=("Any", 12))

        self.window = make_window()
        shared.gui_window = self.window

        self.enable_buttons()

        self.window_state_from_settings()  # type: ignore
        last_window_height: int = self.window.Size[1]  # type: ignore

        while True:
            event, values = self.window.read()  # type: ignore
            if DEBUG_SHOW_MAIN_EVENT_LOOP and (
                # ignore event generated by logger to prevent infinite loop
                not (event == keys.logging)
            ):
                if event in values.keys():
                    value = values[event]
                    logger.debug(
                        # display event, its value, type of value and all values
                        f"EVENT LOOP\n{event = },  {value = },  {type(value) = }\nvalues =\n{values}"
                    )
                else:
                    # display event and all values
                    logger.debug(f"EVENT LOOP\n{event = }\nvalues = \n{values}")
            match event:
                case "Conf":
                    window_height: int = self.window.Size[1]  # type: ignore
                    if window_height == last_window_height:
                        continue
                    config_column: sg.Column = self.window[keys.config_column]  # type: ignore
                    self._update_column_height(
                        config_column,
                        window_height,
                        last_window_height,
                        self.col_percent,
                    )
                    last_window_height = window_height

                # Custom logging for GUI, see gigui._logging.GUIOutputHandler.emit()
                case keys.logging:
                    message, color = values[event]
                    sg.cprint(message, text_color=color)

                # Custom logging for GUI, see gigui._logging.log
                case keys.log:
                    message, color = values[event]
                    sg.cprint(message, text_color=color, end="")

                # Output
                case keys.open_file:
                    open_file(values[event])

                case keys.start_server_threads:
                    gi_runner = values[event]
                    gi_runner.start_server_threads()

                case keys.gui_open_new_tabs:
                    gi_runner = values[event]
                    gi_runner.gui_open_new_tabs()
                    time.sleep(0.1)
                    log(CLOSE_OUTPUT_VIEWERS_MSG)
                    gi_runner.events.server_shutdown_done.wait()

                # Top level buttons
                ###########################
                case keys.col_percent:
                    self._update_col_percent(last_window_height, values[event])  # type: ignore

                case keys.run:
                    # Update processing of input patterns because dir state may have changed
                    self.process_inputs()  # type: ignore
                    self.queues, self.logging_queue, self.manager = get_runner_queues(
                        self.settings.multicore
                    )
                    self.run(values)

                # Run command has finished
                case keys.end:
                    if self.gi_runner_thread:
                        self.gi_runner_thread.join()
                        if self.manager:
                            self.manager.shutdown()
                    self.gi_runner_thread = None
                    self.enable_buttons()

                case keys.clear:
                    self.window[keys.multiline].update(value="")  # type: ignore

                case keys.help:
                    help_window()

                case keys.about:
                    log(Help.about_info)

                # Exit button clicked
                case keys.exit:
                    break

                # Window closed, or
                case sg.WIN_CLOSED:
                    if self.gi_runner_thread:
                        shared.gui_window_closed = True
                        self.gi_runner_thread.join()
                        if self.manager:
                            self.manager.shutdown()
                    break

                # IO configuration
                ##################################
                case keys.input_fstrs:
                    self.process_input_fstrs(values[event])

                case keys.outfile_base:
                    self.update_outfile_str()

                case event if event in (keys.postfix, keys.prefix, keys.nofix):
                    self.fix = event
                    self.update_outfile_str()

                case keys.subfolder:
                    self.subfolder = to_posix_fstr(values[event])
                    self.process_inputs()

                case keys.n_files:
                    self.process_n_files(values[keys.n_files], self.window[event])  # type: ignore

                # Output generation and formatting
                ##################################
                case keys.auto:
                    self.process_view_format_radio_buttons(event)

                case keys.dynamic_blame_history:
                    self.process_view_format_radio_buttons(event)

                case keys.html:
                    self.process_view_format_radio_buttons(event)

                case keys.html_blame_history:
                    self.process_view_format_radio_buttons(event)

                case keys.excel:
                    self.process_view_format_radio_buttons(event)

                case keys.verbosity:
                    set_logging_level_from_verbosity(values[event])

                # Settings
                ##################################
                case keys.save:
                    self.settings.from_values_dict(values)
                    self.settings.gui_settings_full_path = self.gui_settings_full_path
                    self.settings.save()
                    log("Settings saved to " + SettingsFile.get_settings_file())

                case keys.save_as:
                    self.settings.from_values_dict(values)
                    self.settings.gui_settings_full_path = self.gui_settings_full_path
                    destination = values[keys.save_as]
                    self.settings.save_as(destination)
                    self.update_settings_file_str(self.gui_settings_full_path)
                    log(f"Settings saved to {str(SettingsFile.get_location_path())}")

                case keys.load:
                    settings_file = values[keys.load]
                    settings_folder = str(Path(settings_file).parent)
                    self.settings.load_safe_from(settings_file)
                    SettingsFile.set_location(settings_file)
                    self.window[keys.load].InitialFolder = settings_folder  # type: ignore
                    self.window_state_from_settings()
                    self.update_settings_file_str(self.gui_settings_full_path)
                    log(f"Settings loaded from {settings_file}")

                case keys.reset:
                    self.settings.reset()
                    self.window.close()
                    recreate_window = True
                    break  # strangely enough also works without the break

                case keys.reset_file:
                    SettingsFile.reset()
                    self.window.close()
                    recreate_window = True
                    break  # strangely enough also works without the break

                case keys.toggle_settings_file:
                    self.gui_settings_full_path = not self.gui_settings_full_path
                    if self.gui_settings_full_path:
                        self.update_settings_file_str(True)
                    else:
                        self.update_settings_file_str(False)

        return recreate_window

    def run(  # pylint: disable=too-many-branches
        self,
        values: dict,
    ) -> None:
        start_time = time.time()
        logger.debug(f"{values = }")  # type: ignore

        if self.input_fstrs and not self.input_fstr_matches:
            popup("Error", "Input folder path invalid")
            return

        if not self.input_fstrs:
            popup("Error", "Input folder path empty")
            return

        if not self.outfile_base:
            popup("Error", "Output file base empty")
            return

        if not self.subfolder_valid:
            popup(
                "Error",
                "Subfolder invalid: should be empty or a folder that exists in the "
                '"Input folder path"',
            )
            return

        args = Args()
        settings_schema: dict[str, Any] = SettingsFile.SETTINGS_SCHEMA["properties"]
        for schema_key, schema_value in settings_schema.items():
            if schema_key not in {
                keys.profile,
                keys.fix,
                keys.n_files,
                keys.view,
                keys.file_formats,
                keys.since,
                keys.until,
                keys.multithread,
                keys.gui_settings_full_path,
            }:
                if schema_value["type"] == "array":
                    setattr(args, schema_key, values[schema_key].split(","))  # type: ignore
                else:
                    setattr(args, schema_key, values[schema_key])

        args.multithread = self.multithread

        if values[keys.prefix]:
            args.fix = keys.prefix
        elif values[keys.postfix]:
            args.fix = keys.postfix
        else:
            args.fix = keys.nofix

        if values[keys.auto]:
            args.view = AUTO
        elif values[keys.dynamic_blame_history]:
            args.view = DYNAMIC_BLAME_HISTORY
        else:
            args.view = NONE

        args.n_files = 0 if not values[keys.n_files] else int(values[keys.n_files])

        file_formats = []
        for schema_key in FILE_FORMATS:
            if values[schema_key]:
                file_formats.append(schema_key)
        args.file_formats = file_formats

        self.disable_buttons()

        for schema_key in keys.since, keys.until:
            val = values[schema_key]
            if not val or val == "":
                continue
            try:
                val = datetime.strptime(values[schema_key], "%Y-%m-%d").strftime(
                    "%Y-%m-%d"
                )
            except (TypeError, ValueError):
                popup(
                    "Reminder",
                    "Invalid date format. Correct format is YYYY-MM-DD. Please try again.",
                )
                return
            setattr(args, schema_key, str(val))

        args.normalize()

        logger.debug(f"{args = }")  # type: ignore

        self.gi_runner_thread = threading.Thread(
            target=self.start_gi_runner,
            args=(args, start_time, self.queues, self.logging_queue),
            name="GI Runner",
        )
        self.gi_runner_thread.start()

    def start_gi_runner(
        self, args: Args, start_time: float, queues: RunnerQueues, logging_queue: Queue
    ) -> None:
        GIRunner(
            args,
            start_time,
            queues,
            logging_queue,
        ).run_repos()
        if not shared.gui_window_closed:
            self.window.write_event_value(keys.end, None)

    def _update_column_height(
        self,
        element: sg.Element,
        window_height: int,
        last_window_height: int,
        col_percent: int,
    ) -> None:
        column_height = element.Widget.canvas.winfo_height()  # type: ignore
        if column_height < MAX_COL_HEIGHT or (window_height - last_window_height) <= 0:
            column_height = int(
                (window_height - WINDOW_HEIGHT_CORR) * col_percent / 100
            )
            column_height = min(column_height, MAX_COL_HEIGHT)
            element.Widget.canvas.configure({"height": column_height})  # type: ignore

    def _update_col_percent(self, window_height: int, percent: int) -> None:
        config_column: sg.Column = self.window[keys.config_column]  # type: ignore
        if self.col_percent != percent:
            self.col_percent = percent
            self._update_column_height(
                config_column, window_height, window_height, self.col_percent
            )


def main():
    settings: Settings
    settings, _ = SettingsFile.load()
    _logging.ini_for_gui_base()
    add_cli_handler()
    PSGUI(settings)


if __name__ == "__main__":
    # Required for pyinstaller to support the use of multiprocessing in gigui
    multiprocessing.freeze_support()
    main()
